import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, E as Emoji, v as validate_slots, G as binding_callbacks, H as bind, y as create_component, z as claim_component, A as mount_component, I as add_flush_callback, p as transition_in, r as transition_out, B as destroy_component, w as validate_each_argument, e as element, a as space, c as claim_element, b as children, f as claim_space, g as detach_dev, j as attr_dev, k as add_location, l as insert_dev, m as append_dev, q as group_outros, u as check_outros, x as destroy_each, t as text, D as empty, h as claim_text, J as add_render_callback, L as LazyLoad, K as FaAngleDown, M as fly, N as fade, O as query_selector_all, C as listen_dev, P as create_out_transition, Q as set_style, R as create_in_transition } from './client.dc1c2f2e.js';
import './Tag.cc488e9b.js';
import { C as Card, P as PostFilter } from './PostFilter.2f4878b9.js';

/* src/components/Cards.svelte generated by Svelte v3.32.2 */
const file = "src/components/Cards.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	return child_ctx;
}

// (68:0) {#if tags}
function create_if_block_2(ctx) {
	let postfilter;
	let updating_activeTags;
	let updating_activeTypes;
	let current;

	function postfilter_activeTags_binding(value) {
		/*postfilter_activeTags_binding*/ ctx[7](value);
	}

	function postfilter_activeTypes_binding(value) {
		/*postfilter_activeTypes_binding*/ ctx[8](value);
	}

	let postfilter_props = {
		tags: /*tags*/ ctx[4],
		types: /*types*/ ctx[5]
	};

	if (/*activeTags*/ ctx[2] !== void 0) {
		postfilter_props.activeTags = /*activeTags*/ ctx[2];
	}

	if (/*activeTypes*/ ctx[1] !== void 0) {
		postfilter_props.activeTypes = /*activeTypes*/ ctx[1];
	}

	postfilter = new PostFilter({ props: postfilter_props, $$inline: true });
	binding_callbacks.push(() => bind(postfilter, "activeTags", postfilter_activeTags_binding));
	binding_callbacks.push(() => bind(postfilter, "activeTypes", postfilter_activeTypes_binding));

	const block = {
		c: function create() {
			create_component(postfilter.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(postfilter.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(postfilter, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const postfilter_changes = {};

			if (!updating_activeTags && dirty & /*activeTags*/ 4) {
				updating_activeTags = true;
				postfilter_changes.activeTags = /*activeTags*/ ctx[2];
				add_flush_callback(() => updating_activeTags = false);
			}

			if (!updating_activeTypes && dirty & /*activeTypes*/ 2) {
				updating_activeTypes = true;
				postfilter_changes.activeTypes = /*activeTypes*/ ctx[1];
				add_flush_callback(() => updating_activeTypes = false);
			}

			postfilter.$set(postfilter_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(postfilter.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(postfilter.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(postfilter, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(68:0) {#if tags}",
		ctx
	});

	return block;
}

// (73:0) {#if visible}
function create_if_block(ctx) {
	let span;
	let t;
	let current;
	let each_value = /*visible*/ ctx[3];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block = /*visible*/ ctx[3].length % 2 != 0 && create_if_block_1(ctx);

	const block = {
		c: function create() {
			span = element("span");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(span_nodes);
			}

			t = claim_space(span_nodes);
			if (if_block) if_block.l(span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "cont svelte-26pfj0");
			add_location(span, file, 73, 2, 1749);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(span, null);
			}

			append_dev(span, t);
			if (if_block) if_block.m(span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*visible, onHome*/ 9) {
				each_value = /*visible*/ ctx[3];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(span, t);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (/*visible*/ ctx[3].length % 2 != 0) {
				if (if_block) ; else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(span, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(73:0) {#if visible}",
		ctx
	});

	return block;
}

// (75:4) {#each visible as post}
function create_each_block(ctx) {
	let card;
	let updating_onHome;
	let current;

	function card_onHome_binding(value) {
		/*card_onHome_binding*/ ctx[9](value);
	}

	let card_props = { post: /*post*/ ctx[10] };

	if (/*onHome*/ ctx[0] !== void 0) {
		card_props.onHome = /*onHome*/ ctx[0];
	}

	card = new Card({ props: card_props, $$inline: true });
	binding_callbacks.push(() => bind(card, "onHome", card_onHome_binding));

	const block = {
		c: function create() {
			create_component(card.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(card.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(card, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const card_changes = {};
			if (dirty & /*visible*/ 8) card_changes.post = /*post*/ ctx[10];

			if (!updating_onHome && dirty & /*onHome*/ 1) {
				updating_onHome = true;
				card_changes.onHome = /*onHome*/ ctx[0];
				add_flush_callback(() => updating_onHome = false);
			}

			card.$set(card_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(card.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(card.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(card, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(75:4) {#each visible as post}",
		ctx
	});

	return block;
}

// (78:4) {#if visible.length % 2 != 0}
function create_if_block_1(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "placeholder svelte-26pfj0");
			add_location(span, file, 78, 6, 1883);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(78:4) {#if visible.length % 2 != 0}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let h2;
	let t0;
	let emoji;
	let t1;
	let t2;
	let span;
	let t3;
	let if_block1_anchor;
	let current;

	emoji = new Emoji({
			props: { symbol: "ðŸ‘¨â€ðŸ”§" },
			$$inline: true
		});

	let if_block0 = /*tags*/ ctx[4] && create_if_block_2(ctx);
	let if_block1 = /*visible*/ ctx[3] && create_if_block(ctx);

	const block = {
		c: function create() {
			h2 = element("h2");
			t0 = text("Check out my work\n  ");
			create_component(emoji.$$.fragment);
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			span = element("span");
			t3 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", { id: true, class: true });
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, "Check out my work\n  ");
			claim_component(emoji.$$.fragment, h2_nodes);
			h2_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t2 = claim_space(nodes);
			span = claim_element(nodes, "SPAN", { class: true });
			children(span).forEach(detach_dev);
			t3 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "id", "blog");
			attr_dev(h2, "class", "svelte-26pfj0");
			add_location(h2, file, 63, 0, 1555);
			attr_dev(span, "class", "postFilter svelte-26pfj0");
			add_location(span, file, 70, 0, 1704);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h2, anchor);
			append_dev(h2, t0);
			mount_component(emoji, h2, null);
			insert_dev(target, t1, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, span, anchor);
			insert_dev(target, t3, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*tags*/ ctx[4]) if_block0.p(ctx, dirty);

			if (/*visible*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*visible*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(emoji.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(emoji.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
			destroy_component(emoji);
			if (detaching) detach_dev(t1);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(span);
			if (detaching) detach_dev(t3);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let visible;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Cards", slots, []);
	let { posts } = $$props;
	let { onHome } = $$props;

	// Two filters, types (blog posts, journal articles, etc.) and tags (ML, graph theory, etc.).
	let activeTypes = posts
	? new Set([].concat(...posts.map(x => x.type)))
	: undefined;

	let activeTags = posts
	? new Set([].concat(...posts.map(x => x.tags)))
	: undefined;

	let tags = posts ? [...activeTags] : undefined;
	let types = posts ? [...activeTypes] : undefined;
	const writable_props = ["posts", "onHome"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Cards> was created with unknown prop '${key}'`);
	});

	function postfilter_activeTags_binding(value) {
		activeTags = value;
		$$invalidate(2, activeTags);
	}

	function postfilter_activeTypes_binding(value) {
		activeTypes = value;
		$$invalidate(1, activeTypes);
	}

	function card_onHome_binding(value) {
		onHome = value;
		$$invalidate(0, onHome);
	}

	$$self.$$set = $$props => {
		if ("posts" in $$props) $$invalidate(6, posts = $$props.posts);
		if ("onHome" in $$props) $$invalidate(0, onHome = $$props.onHome);
	};

	$$self.$capture_state = () => ({
		Card,
		PostFilter,
		Emoji,
		posts,
		onHome,
		activeTypes,
		activeTags,
		tags,
		types,
		visible
	});

	$$self.$inject_state = $$props => {
		if ("posts" in $$props) $$invalidate(6, posts = $$props.posts);
		if ("onHome" in $$props) $$invalidate(0, onHome = $$props.onHome);
		if ("activeTypes" in $$props) $$invalidate(1, activeTypes = $$props.activeTypes);
		if ("activeTags" in $$props) $$invalidate(2, activeTags = $$props.activeTags);
		if ("tags" in $$props) $$invalidate(4, tags = $$props.tags);
		if ("types" in $$props) $$invalidate(5, types = $$props.types);
		if ("visible" in $$props) $$invalidate(3, visible = $$props.visible);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*posts, activeTags, activeTypes*/ 70) {
			// Make a post visible if its type is set to visible and one of the tags are present.
			 $$invalidate(3, visible = posts.filter(post => post.tags.some(tag => activeTags.has(tag)) && activeTypes.has(post.type)));
		}
	};

	return [
		onHome,
		activeTypes,
		activeTags,
		visible,
		tags,
		types,
		posts,
		postfilter_activeTags_binding,
		postfilter_activeTypes_binding,
		card_onHome_binding
	];
}

class Cards extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { posts: 6, onHome: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Cards",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*posts*/ ctx[6] === undefined && !("posts" in props)) {
			console.warn("<Cards> was created without expected prop 'posts'");
		}

		if (/*onHome*/ ctx[0] === undefined && !("onHome" in props)) {
			console.warn("<Cards> was created without expected prop 'onHome'");
		}
	}

	get posts() {
		throw new Error("<Cards>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set posts(value) {
		throw new Error("<Cards>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onHome() {
		throw new Error("<Cards>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onHome(value) {
		throw new Error("<Cards>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/index.svelte generated by Svelte v3.32.2 */
const file$1 = "src/routes/index.svelte";

// (68:4) {#if visible && onHome}
function create_if_block$1(ctx) {
	let div;
	let h1;
	let t0;
	let emoji0;
	let h1_intro;
	let h1_outro;
	let t1;
	let p0;
	let t2;
	let emoji1;
	let t3;
	let emoji2;
	let t4;
	let a0;
	let t5;
	let t6;
	let emoji3;
	let p0_intro;
	let p0_outro;
	let t7;
	let p1;
	let t8;
	let a1;
	let t9;
	let p1_intro;
	let p1_outro;
	let t10;
	let p2;
	let t11;
	let a2;
	let t12;
	let t13;
	let emoji4;
	let p2_intro;
	let p2_outro;
	let t14;
	let span;
	let faangledown;
	let span_intro;
	let span_outro;
	let current;
	emoji0 = new Emoji({ props: { symbol: "ðŸ‘‹" }, $$inline: true });
	emoji1 = new Emoji({ props: { symbol: "ðŸ“ˆ" }, $$inline: true });

	emoji2 = new Emoji({
			props: { symbol: "ðŸ§‘â€ðŸ’»" },
			$$inline: true
		});

	emoji3 = new Emoji({
			props: { symbol: "ðŸ«ðŸ¯" },
			$$inline: true
		});

	emoji4 = new Emoji({ props: { symbol: "âš–ï¸" }, $$inline: true });
	faangledown = new FaAngleDown({ $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			h1 = element("h1");
			t0 = text("Hello\n          ");
			create_component(emoji0.$$.fragment);
			t1 = space();
			p0 = element("p");
			t2 = text("I'm Cameron - a data scientist\n          ");
			create_component(emoji1.$$.fragment);
			t3 = text("\n          and graduate student\n          ");
			create_component(emoji2.$$.fragment);
			t4 = text("\n          at the\n          ");
			a0 = element("a");
			t5 = text("University of Oxford");
			t6 = space();
			create_component(emoji3.$$.fragment);
			t7 = space();
			p1 = element("p");
			t8 = text("Previously a research scientist at the University of Toronto's\n          ");
			a1 = element("a");
			t9 = text("Computational Social Science Lab");
			t10 = space();
			p2 = element("p");
			t11 = text("And an incoming research fellow at\n          ");
			a2 = element("a");
			t12 = text("Stanford Law School");
			t13 = space();
			create_component(emoji4.$$.fragment);
			t14 = space();
			span = element("span");
			create_component(faangledown.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			h1 = claim_element(div_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Hello\n          ");
			claim_component(emoji0.$$.fragment, h1_nodes);
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			p0 = claim_element(div_nodes, "P", {});
			var p0_nodes = children(p0);
			t2 = claim_text(p0_nodes, "I'm Cameron - a data scientist\n          ");
			claim_component(emoji1.$$.fragment, p0_nodes);
			t3 = claim_text(p0_nodes, "\n          and graduate student\n          ");
			claim_component(emoji2.$$.fragment, p0_nodes);
			t4 = claim_text(p0_nodes, "\n          at the\n          ");
			a0 = claim_element(p0_nodes, "A", { "aria-label": true, href: true });
			var a0_nodes = children(a0);
			t5 = claim_text(a0_nodes, "University of Oxford");
			a0_nodes.forEach(detach_dev);
			t6 = claim_space(p0_nodes);
			claim_component(emoji3.$$.fragment, p0_nodes);
			p0_nodes.forEach(detach_dev);
			t7 = claim_space(div_nodes);
			p1 = claim_element(div_nodes, "P", {});
			var p1_nodes = children(p1);
			t8 = claim_text(p1_nodes, "Previously a research scientist at the University of Toronto's\n          ");
			a1 = claim_element(p1_nodes, "A", { "aria-label": true, href: true });
			var a1_nodes = children(a1);
			t9 = claim_text(a1_nodes, "Computational Social Science Lab");
			a1_nodes.forEach(detach_dev);
			p1_nodes.forEach(detach_dev);
			t10 = claim_space(div_nodes);
			p2 = claim_element(div_nodes, "P", {});
			var p2_nodes = children(p2);
			t11 = claim_text(p2_nodes, "And an incoming research fellow at\n          ");
			a2 = claim_element(p2_nodes, "A", { "aria-label": true, href: true });
			var a2_nodes = children(a2);
			t12 = claim_text(a2_nodes, "Stanford Law School");
			a2_nodes.forEach(detach_dev);
			t13 = claim_space(p2_nodes);
			claim_component(emoji4.$$.fragment, p2_nodes);
			p2_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			t14 = claim_space(nodes);
			span = claim_element(nodes, "SPAN", { style: true, class: true });
			var span_nodes = children(span);
			claim_component(faangledown.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", "svelte-1jd95ya");
			add_location(h1, file$1, 69, 8, 1515);
			attr_dev(a0, "aria-label", "University of Oxford");
			attr_dev(a0, "href", "http://www.ox.ac.uk/");
			add_location(a0, file$1, 83, 10, 1961);
			add_location(p0, file$1, 75, 8, 1690);
			attr_dev(a1, "aria-label", "University of Toronto");
			attr_dev(a1, "href", "http://csslab.cs.toronto.edu/");
			add_location(a1, file$1, 92, 10, 2318);
			add_location(p1, file$1, 88, 8, 2130);
			attr_dev(a2, "aria-label", "Stanford Law School");
			attr_dev(a2, "href", "https://law.stanford.edu/");
			add_location(a2, file$1, 102, 10, 2659);
			add_location(p2, file$1, 98, 8, 2499);
			attr_dev(div, "class", "intro svelte-1jd95ya");
			add_location(div, file$1, 68, 6, 1487);
			set_style(span, "opacity", 1 - Math.max(0, /*y*/ ctx[1] / 500));
			attr_dev(span, "class", "down-arrow svelte-1jd95ya");
			add_location(span, file$1, 108, 6, 2840);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, h1);
			append_dev(h1, t0);
			mount_component(emoji0, h1, null);
			append_dev(div, t1);
			append_dev(div, p0);
			append_dev(p0, t2);
			mount_component(emoji1, p0, null);
			append_dev(p0, t3);
			mount_component(emoji2, p0, null);
			append_dev(p0, t4);
			append_dev(p0, a0);
			append_dev(a0, t5);
			append_dev(p0, t6);
			mount_component(emoji3, p0, null);
			append_dev(div, t7);
			append_dev(div, p1);
			append_dev(p1, t8);
			append_dev(p1, a1);
			append_dev(a1, t9);
			append_dev(div, t10);
			append_dev(div, p2);
			append_dev(p2, t11);
			append_dev(p2, a2);
			append_dev(a2, t12);
			append_dev(p2, t13);
			mount_component(emoji4, p2, null);
			insert_dev(target, t14, anchor);
			insert_dev(target, span, anchor);
			mount_component(faangledown, span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty & /*y*/ 2) {
				set_style(span, "opacity", 1 - Math.max(0, /*y*/ ctx[1] / 500));
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(emoji0.$$.fragment, local);

			add_render_callback(() => {
				if (h1_outro) h1_outro.end(1);
				if (!h1_intro) h1_intro = create_in_transition(h1, fly, { y: 50, duration: 500 });
				h1_intro.start();
			});

			transition_in(emoji1.$$.fragment, local);
			transition_in(emoji2.$$.fragment, local);
			transition_in(emoji3.$$.fragment, local);

			add_render_callback(() => {
				if (p0_outro) p0_outro.end(1);
				if (!p0_intro) p0_intro = create_in_transition(p0, fly, { delay: 300, y: 50, duration: 500 });
				p0_intro.start();
			});

			add_render_callback(() => {
				if (p1_outro) p1_outro.end(1);
				if (!p1_intro) p1_intro = create_in_transition(p1, fly, { delay: 350, y: 50, duration: 500 });
				p1_intro.start();
			});

			transition_in(emoji4.$$.fragment, local);

			add_render_callback(() => {
				if (p2_outro) p2_outro.end(1);
				if (!p2_intro) p2_intro = create_in_transition(p2, fly, { delay: 400, y: 50, duration: 500 });
				p2_intro.start();
			});

			transition_in(faangledown.$$.fragment, local);

			add_render_callback(() => {
				if (span_outro) span_outro.end(1);
				if (!span_intro) span_intro = create_in_transition(span, fade, { duration: 500, delay: 3000 });
				span_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(emoji0.$$.fragment, local);
			if (h1_intro) h1_intro.invalidate();
			h1_outro = create_out_transition(h1, fly, { delay: 50, y: 50, duration: 500 });
			transition_out(emoji1.$$.fragment, local);
			transition_out(emoji2.$$.fragment, local);
			transition_out(emoji3.$$.fragment, local);
			if (p0_intro) p0_intro.invalidate();
			p0_outro = create_out_transition(p0, fly, { y: 50, duration: 500 });
			if (p1_intro) p1_intro.invalidate();
			p1_outro = create_out_transition(p1, fly, { y: 50, duration: 500 });
			transition_out(emoji4.$$.fragment, local);
			if (p2_intro) p2_intro.invalidate();
			p2_outro = create_out_transition(p2, fly, { y: 50, duration: 500 });
			transition_out(faangledown.$$.fragment, local);
			if (span_intro) span_intro.invalidate();
			span_outro = create_out_transition(span, fade, { duration: 500 });
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(emoji0);
			if (detaching && h1_outro) h1_outro.end();
			destroy_component(emoji1);
			destroy_component(emoji2);
			destroy_component(emoji3);
			if (detaching && p0_outro) p0_outro.end();
			if (detaching && p1_outro) p1_outro.end();
			destroy_component(emoji4);
			if (detaching && p2_outro) p2_outro.end();
			if (detaching) detach_dev(t14);
			if (detaching) detach_dev(span);
			destroy_component(faangledown);
			if (detaching && span_outro) span_outro.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(68:4) {#if visible && onHome}",
		ctx
	});

	return block;
}

// (67:2) <LazyLoad let:hasBeenVisible let:visible>
function create_default_slot(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*visible*/ ctx[6] && /*onHome*/ ctx[2] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*visible*/ ctx[6] && /*onHome*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*visible, onHome*/ 68) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(67:2) <LazyLoad let:hasBeenVisible let:visible>",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let scrolling = false;

	let clear_scrolling = () => {
		scrolling = false;
	};

	let scrolling_timeout;
	let div;
	let lazyload;
	let t0;
	let img;
	let img_src_value;
	let img_outro;
	let t1;
	let cards;
	let updating_onHome;
	let t2;
	let meta0;
	let meta1;
	let link;
	let meta2;
	let meta3;
	let meta4;
	let meta5;
	let meta6;
	let meta7;
	let meta8;
	let meta9;
	let meta10;
	let meta11;
	let current;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowscroll*/ ctx[3]);

	lazyload = new LazyLoad({
			props: {
				$$slots: {
					default: [
						create_default_slot,
						({ hasBeenVisible, visible }) => ({ 5: hasBeenVisible, 6: visible }),
						({ hasBeenVisible, visible }) => (hasBeenVisible ? 32 : 0) | (visible ? 64 : 0)
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	function cards_onHome_binding(value) {
		/*cards_onHome_binding*/ ctx[4](value);
	}

	let cards_props = { posts: /*posts*/ ctx[0] };

	if (/*onHome*/ ctx[2] !== void 0) {
		cards_props.onHome = /*onHome*/ ctx[2];
	}

	cards = new Cards({ props: cards_props, $$inline: true });
	binding_callbacks.push(() => bind(cards, "onHome", cards_onHome_binding));

	const block = {
		c: function create() {
			div = element("div");
			create_component(lazyload.$$.fragment);
			t0 = space();
			img = element("img");
			t1 = space();
			create_component(cards.$$.fragment);
			t2 = space();
			meta0 = element("meta");
			meta1 = element("meta");
			link = element("link");
			meta2 = element("meta");
			meta3 = element("meta");
			meta4 = element("meta");
			meta5 = element("meta");
			meta6 = element("meta");
			meta7 = element("meta");
			meta8 = element("meta");
			meta9 = element("meta");
			meta10 = element("meta");
			meta11 = element("meta");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(lazyload.$$.fragment, div_nodes);
			t0 = claim_space(div_nodes);
			img = claim_element(div_nodes, "IMG", { src: true, alt: true, class: true });
			div_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(cards.$$.fragment, nodes);
			t2 = claim_space(nodes);
			const head_nodes = query_selector_all("[data-svelte=\"svelte-1axdpzt\"]", document.head);
			meta0 = claim_element(head_nodes, "META", { name: true, content: true });
			meta1 = claim_element(head_nodes, "META", { name: true, content: true });
			link = claim_element(head_nodes, "LINK", { rel: true, href: true });
			meta2 = claim_element(head_nodes, "META", { property: true, content: true });
			meta3 = claim_element(head_nodes, "META", { property: true, content: true });
			meta4 = claim_element(head_nodes, "META", { property: true, content: true });
			meta5 = claim_element(head_nodes, "META", { name: true, content: true });
			meta6 = claim_element(head_nodes, "META", { property: true, content: true });
			meta7 = claim_element(head_nodes, "META", { property: true, content: true });
			meta8 = claim_element(head_nodes, "META", { property: true, content: true });
			meta9 = claim_element(head_nodes, "META", { property: true, content: true });
			meta10 = claim_element(head_nodes, "META", { property: true, content: true });
			meta11 = claim_element(head_nodes, "META", { property: true, content: true });
			head_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			if (img.src !== (img_src_value = "intro.svg")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "");
			attr_dev(img, "class", "intro-svg svelte-1jd95ya");
			add_location(img, file$1, 118, 2, 3077);
			attr_dev(div, "class", "cont svelte-1jd95ya");
			add_location(div, file$1, 65, 0, 1390);
			document.title = "ðŸ¤¯Cameron RaymondðŸ¤¯";
			attr_dev(meta0, "name", "description");
			attr_dev(meta0, "content", "Cameron Raymond is a data scientist and incoming graduate student\n    at the University of Oxford. His broad areas of interest include network\n    science, machine learning, and computational social science.");
			add_location(meta0, file$1, 128, 2, 3274);
			attr_dev(meta1, "name", "keywords");
			attr_dev(meta1, "content", "Cameron Raymond, University of Oxford, Oxford University, Data\n    Science, Social Data Sience, Data Scientist");
			add_location(meta1, file$1, 133, 2, 3530);
			attr_dev(link, "rel", "canonical");
			attr_dev(link, "href", "https://cameronraymond.me");
			add_location(link, file$1, 137, 2, 3686);
			attr_dev(meta2, "property", "og:type");
			attr_dev(meta2, "content", "website");
			add_location(meta2, file$1, 140, 2, 3780);
			attr_dev(meta3, "property", "og:url");
			attr_dev(meta3, "content", "https://cameronraymond.me");
			add_location(meta3, file$1, 141, 2, 3828);
			attr_dev(meta4, "property", "og:title");
			attr_dev(meta4, "content", "ðŸ¤¯Cameron RaymondðŸ¤¯");
			add_location(meta4, file$1, 142, 2, 3893);
			attr_dev(meta5, "name", "og:description");
			attr_dev(meta5, "content", "Cameron Raymond is a data scientist and incoming graduate student\n    at the University of Oxford. His broad areas of interest include network\n    science, machine learning, and computational social science.");
			add_location(meta5, file$1, 143, 2, 3954);
			attr_dev(meta6, "property", "og:image");
			attr_dev(meta6, "content", "https://cameronraymond.me/summary_large_image.png");
			add_location(meta6, file$1, 148, 2, 4213);
			attr_dev(meta7, "property", "twitter:card");
			attr_dev(meta7, "content", "summary_large_image");
			add_location(meta7, file$1, 153, 2, 4332);
			attr_dev(meta8, "property", "twitter:url");
			attr_dev(meta8, "content", "https://cameronraymond.me");
			add_location(meta8, file$1, 154, 2, 4397);
			attr_dev(meta9, "property", "twitter:title");
			attr_dev(meta9, "content", "ðŸ¤¯Cameron RaymondðŸ¤¯");
			add_location(meta9, file$1, 155, 2, 4467);
			attr_dev(meta10, "property", "twitter:description");
			attr_dev(meta10, "content", "Cameron Raymond is a data scientist and incoming graduate student\n    at the University of Oxford.");
			add_location(meta10, file$1, 156, 2, 4533);
			attr_dev(meta11, "property", "twitter:image");
			attr_dev(meta11, "content", "https://cameronraymond.me/summary_large_image.png");
			add_location(meta11, file$1, 160, 2, 4692);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(lazyload, div, null);
			append_dev(div, t0);
			append_dev(div, img);
			insert_dev(target, t1, anchor);
			mount_component(cards, target, anchor);
			insert_dev(target, t2, anchor);
			append_dev(document.head, meta0);
			append_dev(document.head, meta1);
			append_dev(document.head, link);
			append_dev(document.head, meta2);
			append_dev(document.head, meta3);
			append_dev(document.head, meta4);
			append_dev(document.head, meta5);
			append_dev(document.head, meta6);
			append_dev(document.head, meta7);
			append_dev(document.head, meta8);
			append_dev(document.head, meta9);
			append_dev(document.head, meta10);
			append_dev(document.head, meta11);
			current = true;

			if (!mounted) {
				dispose = listen_dev(window, "scroll", () => {
					scrolling = true;
					clearTimeout(scrolling_timeout);
					scrolling_timeout = setTimeout(clear_scrolling, 100);
					/*onwindowscroll*/ ctx[3]();
				});

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*y*/ 2 && !scrolling) {
				scrolling = true;
				clearTimeout(scrolling_timeout);
				scrollTo(window.pageXOffset, /*y*/ ctx[1]);
				scrolling_timeout = setTimeout(clear_scrolling, 100);
			}

			const lazyload_changes = {};

			if (dirty & /*$$scope, y, visible, onHome*/ 198) {
				lazyload_changes.$$scope = { dirty, ctx };
			}

			lazyload.$set(lazyload_changes);
			const cards_changes = {};
			if (dirty & /*posts*/ 1) cards_changes.posts = /*posts*/ ctx[0];

			if (!updating_onHome && dirty & /*onHome*/ 4) {
				updating_onHome = true;
				cards_changes.onHome = /*onHome*/ ctx[2];
				add_flush_callback(() => updating_onHome = false);
			}

			cards.$set(cards_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(lazyload.$$.fragment, local);
			if (img_outro) img_outro.end(1);
			transition_in(cards.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(lazyload.$$.fragment, local);
			img_outro = create_out_transition(img, fade, { duration: 100, delay: 100 });
			transition_out(cards.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(lazyload);
			if (detaching && img_outro) img_outro.end();
			if (detaching) detach_dev(t1);
			destroy_component(cards, detaching);
			if (detaching) detach_dev(t2);
			detach_dev(meta0);
			detach_dev(meta1);
			detach_dev(link);
			detach_dev(meta2);
			detach_dev(meta3);
			detach_dev(meta4);
			detach_dev(meta5);
			detach_dev(meta6);
			detach_dev(meta7);
			detach_dev(meta8);
			detach_dev(meta9);
			detach_dev(meta10);
			detach_dev(meta11);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function preload({ params, query }) {
	return this.fetch(`index.json`).then(r => r.json()).then(posts => {
		return { posts };
	});
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Routes", slots, []);
	let y;
	let onHome = true;
	let { posts } = $$props;
	const writable_props = ["posts"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Routes> was created with unknown prop '${key}'`);
	});

	function onwindowscroll() {
		$$invalidate(1, y = window.pageYOffset);
	}

	function cards_onHome_binding(value) {
		onHome = value;
		$$invalidate(2, onHome);
	}

	$$self.$$set = $$props => {
		if ("posts" in $$props) $$invalidate(0, posts = $$props.posts);
	};

	$$self.$capture_state = () => ({
		preload,
		Emoji,
		Cards,
		LazyLoad,
		FaAngleDown,
		fly,
		fade,
		y,
		onHome,
		posts
	});

	$$self.$inject_state = $$props => {
		if ("y" in $$props) $$invalidate(1, y = $$props.y);
		if ("onHome" in $$props) $$invalidate(2, onHome = $$props.onHome);
		if ("posts" in $$props) $$invalidate(0, posts = $$props.posts);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [posts, y, onHome, onwindowscroll, cards_onHome_binding];
}

class Routes extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { posts: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Routes",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*posts*/ ctx[0] === undefined && !("posts" in props)) {
			console.warn("<Routes> was created without expected prop 'posts'");
		}
	}

	get posts() {
		throw new Error("<Routes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set posts(value) {
		throw new Error("<Routes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Routes;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguOWUyNmU0YmEuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL0NhcmRzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvaW5kZXguc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gIGltcG9ydCBDYXJkIGZyb20gXCIuL0NhcmQuc3ZlbHRlXCI7XG4gIGltcG9ydCBQb3N0RmlsdGVyIGZyb20gXCIuL1Bvc3RGaWx0ZXIuc3ZlbHRlXCI7XG4gIGltcG9ydCBFbW9qaSBmcm9tIFwiLi9FbW9qaS5zdmVsdGVcIjtcbiAgZXhwb3J0IGxldCBwb3N0cztcbiAgZXhwb3J0IGxldCBvbkhvbWU7XG4gIC8vIFR3byBmaWx0ZXJzLCB0eXBlcyAoYmxvZyBwb3N0cywgam91cm5hbCBhcnRpY2xlcywgZXRjLikgYW5kIHRhZ3MgKE1MLCBncmFwaCB0aGVvcnksIGV0Yy4pLlxuICBsZXQgYWN0aXZlVHlwZXMgPSBwb3N0cyBcbiAgICA/IG5ldyBTZXQoW10uY29uY2F0KC4uLnBvc3RzLm1hcCh4ID0+IHgudHlwZSkpKVxuICAgIDogdW5kZWZpbmVkOyAgXG4gIGxldCBhY3RpdmVUYWdzID0gcG9zdHMgXG4gICAgPyBuZXcgU2V0KFtdLmNvbmNhdCguLi5wb3N0cy5tYXAoeCA9PiB4LnRhZ3MpKSlcbiAgICA6IHVuZGVmaW5lZDtcbiAgbGV0IHRhZ3MgPSBwb3N0cyA/IFsuLi5hY3RpdmVUYWdzXSA6IHVuZGVmaW5lZDtcbiAgbGV0IHR5cGVzID0gcG9zdHMgPyBbLi4uYWN0aXZlVHlwZXNdIDogdW5kZWZpbmVkO1xuICAvLyBNYWtlIGEgcG9zdCB2aXNpYmxlIGlmIGl0cyB0eXBlIGlzIHNldCB0byB2aXNpYmxlIGFuZCBvbmUgb2YgdGhlIHRhZ3MgYXJlIHByZXNlbnQuXG4gICQ6IHZpc2libGUgPSBwb3N0cy5maWx0ZXIocG9zdCA9PiBwb3N0LnRhZ3Muc29tZSh0YWcgPT4gYWN0aXZlVGFncy5oYXModGFnKSkgJiYgYWN0aXZlVHlwZXMuaGFzKHBvc3QudHlwZSkpO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgaDIge1xuICAgIG1hcmdpbi10b3A6IDJyZW07XG4gICAgbWFyZ2luLWJvdHRvbTogMy41cmVtO1xuICB9XG4gIC5wb3N0RmlsdGVyIHtcbiAgICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XG4gIH1cbiAgLmNvbnQge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleDogMTtcbiAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWV2ZW5seTtcbiAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAgbWFyZ2luOiAxcmVtO1xuICAgIG1heC13aWR0aDogNzBlbTtcbiAgfVxuICAucGxhY2Vob2xkZXIge1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICB3aWR0aDogMzByZW07XG4gICAgaGVpZ2h0OiAwO1xuICAgIG1hcmdpbi1sZWZ0OiAxcmVtO1xuICAgIG1hcmdpbi1yaWdodDogMXJlbTtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZmZmO1xuICB9XG4gIEBtZWRpYSAobWF4LXdpZHRoOiA0MHJlbSkge1xuICAgIGgyIHtcbiAgICAgIG1hcmdpbi1ib3R0b206IDJyZW07XG4gICAgfVxuICAgIC5jb250IHtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgbWFyZ2luLWxlZnQ6IC0ycmVtO1xuICAgICAgbWFyZ2luLXJpZ2h0OiAtMnJlbTtcbiAgICB9XG4gICAgLnBsYWNlaG9sZGVyIHtcbiAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuICB9XG48L3N0eWxlPlxuXG48aDIgaWQ9XCJibG9nXCI+XG4gIENoZWNrIG91dCBteSB3b3JrXG4gIDxFbW9qaSBzeW1ib2w9XCLwn5Go4oCN8J+Up1wiIC8+XG48L2gyPlxueyNpZiB0YWdzfVxuICA8UG9zdEZpbHRlciB7dGFnc30ge3R5cGVzfSBiaW5kOmFjdGl2ZVRhZ3MgYmluZDphY3RpdmVUeXBlcy8+XG57L2lmfVxuPHNwYW4gY2xhc3M9XCJwb3N0RmlsdGVyXCIgLz5cblxueyNpZiB2aXNpYmxlfVxuICA8c3BhbiBjbGFzcz1cImNvbnRcIj5cbiAgICB7I2VhY2ggdmlzaWJsZSBhcyBwb3N0fVxuICAgICAgPENhcmQge3Bvc3R9IGJpbmQ6b25Ib21lIC8+XG4gICAgey9lYWNofVxuICAgIHsjaWYgdmlzaWJsZS5sZW5ndGggJSAyICE9IDB9XG4gICAgICA8c3BhbiBjbGFzcz1cInBsYWNlaG9sZGVyXCIgLz5cbiAgICB7L2lmfVxuICA8L3NwYW4+XG57L2lmfVxuIiwiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG4gIGV4cG9ydCBmdW5jdGlvbiBwcmVsb2FkKHsgcGFyYW1zLCBxdWVyeSB9KSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2goYGluZGV4Lmpzb25gKVxuICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgIC50aGVuKHBvc3RzID0+IHtcbiAgICAgICAgcmV0dXJuIHsgcG9zdHMgfTtcbiAgICAgIH0pO1xuICB9XG48L3NjcmlwdD5cblxuPHNjcmlwdD5cbiAgaW1wb3J0IEVtb2ppIGZyb20gXCIuLi9jb21wb25lbnRzL0Vtb2ppLnN2ZWx0ZVwiO1xuICBpbXBvcnQgQ2FyZHMgZnJvbSBcIi4uL2NvbXBvbmVudHMvQ2FyZHMuc3ZlbHRlXCI7XG4gIGltcG9ydCBMYXp5TG9hZCBmcm9tIFwiLi4vY29tcG9uZW50cy9Ib0MvTGF6eUxvYWQuc3ZlbHRlXCI7XG4gIGltcG9ydCB7IEZhQW5nbGVEb3duIH0gZnJvbSBcInN2ZWx0ZS1pY29ucy9mYVwiO1xuICBpbXBvcnQgeyBmbHksIGZhZGUgfSBmcm9tIFwic3ZlbHRlL3RyYW5zaXRpb25cIjtcbiAgLy8gV2hlbiB5b3UgY2xpY2sgb24gdGhlIFwiUmVhZCBNb3JlXCIgc2VjdGlvbiBvZiBhIGNhcmQsIGl0IHNldHMgb25Ib21lIGZyb21cbiAgLy8gdHJ1ZSB0byBmYWxzZSBhbmQgcmVtb3ZlcyB0aGUgaW50cm8gY29udGVudCBmcm9tIHRoZSBET01cbiAgbGV0IHk7XG4gIGxldCBvbkhvbWUgPSB0cnVlO1xuICBleHBvcnQgbGV0IHBvc3RzO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cbiAgLmNvbnQge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBtaW4taGVpZ2h0OiAyNXJlbTtcbiAgICBoZWlnaHQ6IGNhbGMoMTAwdmggLSA0ZW0pO1xuICAgIHdpZHRoOiBjYWxjKDEwMHZ3IC0gNGVtKTtcbiAgfVxuICAuaW50cm8ge1xuICAgIHBhZGRpbmctbGVmdDogMXJlbTtcbiAgICBwYWRkaW5nLXRvcDogMTByZW07XG4gICAgcGFkZGluZy1yaWdodDogOHJlbTtcbiAgfVxuICBAbWVkaWEgKG1pbi13aWR0aDogNDAwKSB7XG4gICAgaDEge1xuICAgICAgZm9udC1zaXplOiA0ZW07XG4gICAgfVxuICAgIC5pbnRybyB7XG4gICAgICBwYWRkaW5nLXJpZ2h0OiAwcmVtO1xuICAgIH1cbiAgfVxuICAuaW50cm8tc3ZnIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm90dG9tOiAwO1xuICAgIHJpZ2h0OiAtMXJlbTtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBtYXgtd2lkdGg6IDQycmVtO1xuICAgIG1pbi13aWR0aDogMzVyZW07XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICB6LWluZGV4OiAtMTtcbiAgfVxuICAuZG93bi1hcnJvdyB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGJvdHRvbTogNHJlbTtcbiAgICBsZWZ0OiBjYWxjKDUwdncgLSA0ZW0pO1xuICAgIGNvbG9yOiByZ2IoMjU1LCA2MiwgMCk7XG4gICAgaGVpZ2h0OiAyLjVyZW07XG4gICAgd2lkdGg6IDIuNXJlbTtcbiAgfVxuPC9zdHlsZT5cblxuPHN2ZWx0ZTp3aW5kb3cgYmluZDpzY3JvbGxZPXt5fSAvPlxuXG48ZGl2IGNsYXNzPVwiY29udFwiPlxuICA8TGF6eUxvYWQgbGV0Omhhc0JlZW5WaXNpYmxlIGxldDp2aXNpYmxlPlxuICAgIHsjaWYgdmlzaWJsZSAmJiBvbkhvbWV9XG4gICAgICA8ZGl2IGNsYXNzPVwiaW50cm9cIj5cbiAgICAgICAgPGgxXG4gICAgICAgICAgaW46Zmx5PXt7IHk6IDUwLCBkdXJhdGlvbjogNTAwIH19XG4gICAgICAgICAgb3V0OmZseT17eyBkZWxheTogNTAsIHk6IDUwLCBkdXJhdGlvbjogNTAwIH19PlxuICAgICAgICAgIEhlbGxvXG4gICAgICAgICAgPEVtb2ppIHN5bWJvbD1cIvCfkYtcIiAvPlxuICAgICAgICA8L2gxPlxuICAgICAgICA8cFxuICAgICAgICAgIGluOmZseT17eyBkZWxheTogMzAwLCB5OiA1MCwgZHVyYXRpb246IDUwMCB9fVxuICAgICAgICAgIG91dDpmbHk9e3sgeTogNTAsIGR1cmF0aW9uOiA1MDAgfX0+XG4gICAgICAgICAgSSdtIENhbWVyb24gLSBhIGRhdGEgc2NpZW50aXN0XG4gICAgICAgICAgPEVtb2ppIHN5bWJvbD1cIvCfk4hcIiAvPlxuICAgICAgICAgIGFuZCBncmFkdWF0ZSBzdHVkZW50XG4gICAgICAgICAgPEVtb2ppIHN5bWJvbD1cIvCfp5HigI3wn5K7XCIgLz5cbiAgICAgICAgICBhdCB0aGVcbiAgICAgICAgICA8YSBhcmlhLWxhYmVsPVwiVW5pdmVyc2l0eSBvZiBPeGZvcmRcIiBocmVmPVwiaHR0cDovL3d3dy5veC5hYy51ay9cIj5cbiAgICAgICAgICAgIFVuaXZlcnNpdHkgb2YgT3hmb3JkXG4gICAgICAgICAgPC9hPlxuICAgICAgICAgIDxFbW9qaSBzeW1ib2w9XCLwn4+r8J+Pr1wiIC8+XG4gICAgICAgIDwvcD5cbiAgICAgICAgPHBcbiAgICAgICAgICBpbjpmbHk9e3sgZGVsYXk6IDM1MCwgeTogNTAsIGR1cmF0aW9uOiA1MDAgfX1cbiAgICAgICAgICBvdXQ6Zmx5PXt7IHk6IDUwLCBkdXJhdGlvbjogNTAwIH19PlxuICAgICAgICAgIFByZXZpb3VzbHkgYSByZXNlYXJjaCBzY2llbnRpc3QgYXQgdGhlIFVuaXZlcnNpdHkgb2YgVG9yb250bydzXG4gICAgICAgICAgPGFcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJVbml2ZXJzaXR5IG9mIFRvcm9udG9cIlxuICAgICAgICAgICAgaHJlZj1cImh0dHA6Ly9jc3NsYWIuY3MudG9yb250by5lZHUvXCI+XG4gICAgICAgICAgICBDb21wdXRhdGlvbmFsIFNvY2lhbCBTY2llbmNlIExhYlxuICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9wPlxuICAgICAgICA8cFxuICAgICAgICAgIGluOmZseT17eyBkZWxheTogNDAwLCB5OiA1MCwgZHVyYXRpb246IDUwMCB9fVxuICAgICAgICAgIG91dDpmbHk9e3sgeTogNTAsIGR1cmF0aW9uOiA1MDAgfX0+XG4gICAgICAgICAgQW5kIGFuIGluY29taW5nIHJlc2VhcmNoIGZlbGxvdyBhdFxuICAgICAgICAgIDxhIGFyaWEtbGFiZWw9XCJTdGFuZm9yZCBMYXcgU2Nob29sXCIgaHJlZj1cImh0dHBzOi8vbGF3LnN0YW5mb3JkLmVkdS9cIj5cbiAgICAgICAgICAgIFN0YW5mb3JkIExhdyBTY2hvb2xcbiAgICAgICAgICA8L2E+XG4gICAgICAgICAgPEVtb2ppIHN5bWJvbD1cIuKalu+4j1wiIC8+XG4gICAgICAgIDwvcD5cbiAgICAgIDwvZGl2PlxuICAgICAgPHNwYW5cbiAgICAgICAgaW46ZmFkZT17eyBkdXJhdGlvbjogNTAwLCBkZWxheTogMzAwMCB9fVxuICAgICAgICBvdXQ6ZmFkZT17eyBkdXJhdGlvbjogNTAwIH19XG4gICAgICAgIHN0eWxlPVwib3BhY2l0eTogezEgLSBNYXRoLm1heCgwLCB5IC8gNTAwKX1cIlxuICAgICAgICBjbGFzcz1cImRvd24tYXJyb3dcIj5cbiAgICAgICAgPEZhQW5nbGVEb3duIC8+XG4gICAgICA8L3NwYW4+XG4gICAgey9pZn1cbiAgPC9MYXp5TG9hZD5cblxuICA8aW1nXG4gICAgc3JjPVwiaW50cm8uc3ZnXCJcbiAgICBhbHQ9XCJcIlxuICAgIGNsYXNzPVwiaW50cm8tc3ZnXCJcbiAgICBvdXQ6ZmFkZT17eyBkdXJhdGlvbjogMTAwLCBkZWxheTogMTAwIH19IC8+XG48L2Rpdj5cbjxDYXJkcyB7cG9zdHN9IGJpbmQ6b25Ib21lIC8+XG48c3ZlbHRlOmhlYWQ+XG4gIDx0aXRsZT7wn6SvQ2FtZXJvbiBSYXltb25k8J+krzwvdGl0bGU+XG5cbiAgPG1ldGFcbiAgICBuYW1lPVwiZGVzY3JpcHRpb25cIlxuICAgIGNvbnRlbnQ9XCJDYW1lcm9uIFJheW1vbmQgaXMgYSBkYXRhIHNjaWVudGlzdCBhbmQgaW5jb21pbmcgZ3JhZHVhdGUgc3R1ZGVudFxuICAgIGF0IHRoZSBVbml2ZXJzaXR5IG9mIE94Zm9yZC4gSGlzIGJyb2FkIGFyZWFzIG9mIGludGVyZXN0IGluY2x1ZGUgbmV0d29ya1xuICAgIHNjaWVuY2UsIG1hY2hpbmUgbGVhcm5pbmcsIGFuZCBjb21wdXRhdGlvbmFsIHNvY2lhbCBzY2llbmNlLlwiIC8+XG4gIDxtZXRhXG4gICAgbmFtZT1cImtleXdvcmRzXCJcbiAgICBjb250ZW50PVwiQ2FtZXJvbiBSYXltb25kLCBVbml2ZXJzaXR5IG9mIE94Zm9yZCwgT3hmb3JkIFVuaXZlcnNpdHksIERhdGFcbiAgICBTY2llbmNlLCBTb2NpYWwgRGF0YSBTaWVuY2UsIERhdGEgU2NpZW50aXN0XCIgLz5cbiAgPGxpbmsgcmVsPVwiY2Fub25pY2FsXCIgaHJlZj1cImh0dHBzOi8vY2FtZXJvbnJheW1vbmQubWVcIiAvPlxuXG4gIDwhLS0gT3BlbiBHcmFwaCAvIEZhY2Vib29rIC0tPlxuICA8bWV0YSBwcm9wZXJ0eT1cIm9nOnR5cGVcIiBjb250ZW50PVwid2Vic2l0ZVwiIC8+XG4gIDxtZXRhIHByb3BlcnR5PVwib2c6dXJsXCIgY29udGVudD1cImh0dHBzOi8vY2FtZXJvbnJheW1vbmQubWVcIiAvPlxuICA8bWV0YSBwcm9wZXJ0eT1cIm9nOnRpdGxlXCIgY29udGVudD1cIvCfpK9DYW1lcm9uIFJheW1vbmTwn6SvXCIgLz5cbiAgPG1ldGFcbiAgICBuYW1lPVwib2c6ZGVzY3JpcHRpb25cIlxuICAgIGNvbnRlbnQ9XCJDYW1lcm9uIFJheW1vbmQgaXMgYSBkYXRhIHNjaWVudGlzdCBhbmQgaW5jb21pbmcgZ3JhZHVhdGUgc3R1ZGVudFxuICAgIGF0IHRoZSBVbml2ZXJzaXR5IG9mIE94Zm9yZC4gSGlzIGJyb2FkIGFyZWFzIG9mIGludGVyZXN0IGluY2x1ZGUgbmV0d29ya1xuICAgIHNjaWVuY2UsIG1hY2hpbmUgbGVhcm5pbmcsIGFuZCBjb21wdXRhdGlvbmFsIHNvY2lhbCBzY2llbmNlLlwiIC8+XG4gIDxtZXRhXG4gICAgcHJvcGVydHk9XCJvZzppbWFnZVwiXG4gICAgY29udGVudD1cImh0dHBzOi8vY2FtZXJvbnJheW1vbmQubWUvc3VtbWFyeV9sYXJnZV9pbWFnZS5wbmdcIiAvPlxuXG4gIDwhLS0gVHdpdHRlciAtLT5cbiAgPG1ldGEgcHJvcGVydHk9XCJ0d2l0dGVyOmNhcmRcIiBjb250ZW50PVwic3VtbWFyeV9sYXJnZV9pbWFnZVwiIC8+XG4gIDxtZXRhIHByb3BlcnR5PVwidHdpdHRlcjp1cmxcIiBjb250ZW50PVwiaHR0cHM6Ly9jYW1lcm9ucmF5bW9uZC5tZVwiIC8+XG4gIDxtZXRhIHByb3BlcnR5PVwidHdpdHRlcjp0aXRsZVwiIGNvbnRlbnQ9XCLwn6SvQ2FtZXJvbiBSYXltb25k8J+kr1wiIC8+XG4gIDxtZXRhXG4gICAgcHJvcGVydHk9XCJ0d2l0dGVyOmRlc2NyaXB0aW9uXCJcbiAgICBjb250ZW50PVwiQ2FtZXJvbiBSYXltb25kIGlzIGEgZGF0YSBzY2llbnRpc3QgYW5kIGluY29taW5nIGdyYWR1YXRlIHN0dWRlbnRcbiAgICBhdCB0aGUgVW5pdmVyc2l0eSBvZiBPeGZvcmQuXCIgLz5cbiAgPG1ldGFcbiAgICBwcm9wZXJ0eT1cInR3aXR0ZXI6aW1hZ2VcIlxuICAgIGNvbnRlbnQ9XCJodHRwczovL2NhbWVyb25yYXltb25kLm1lL3N1bW1hcnlfbGFyZ2VfaW1hZ2UucG5nXCIgLz5cbjwvc3ZlbHRlOmhlYWQ+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4QkEwRVcsR0FBTzs7OztnQ0FBWixNQUFJOzs7Ozs7Ozs0QkFHRCxHQUFPLElBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2QkFIckIsR0FBTzs7OzsrQkFBWixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7O3dCQUFKLE1BQUk7Ozs7Ozs7bUJBR0QsR0FBTyxJQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQzs7Ozs7Ozs7Ozs7Ozs7a0NBSDFCLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFQTCxHQUFJOzZCQUtKLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQUxQLEdBQUk7O21CQUtKLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FwRUMsS0FBSztPQUNMLE1BQU07OztLQUViLFdBQVcsR0FBRyxLQUFLO09BQ2YsR0FBRyxJQUFJLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSTtHQUMxQyxTQUFT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
