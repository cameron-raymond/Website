{"title":"Classifying Shakespeare with Networks","slug":"shakespeare-netlsd","emoji":"ğŸ¿","blurb":"What distinguishes Shakespeare's comedies from his tragedies? Without looking at a single line of dialogue, this article shows that it is possible to use networks to classify Shakespeare's plays. Posted on Towards Data Science.","type":"bp","tags":["gt"],"link":"<a aria-label='Blog' href='https://medium.com/@cameronraymond/classifying-shakespeare-with-networks-2a6c1c44e17f'>Blog</a>","date":"Jun. 18, 2020","prod":true,"html":"<img src=\"https://cdn-images-1.medium.com/max/2000/1*uNiI3fHUS44j-QorVBxJUA.gif\" alt=\"All of Shakespeareâ€™s plays, in network form\"><em>All of Shakespeareâ€™s plays, in network form</em>\n<p>William Shakespeare is one of our most recognizable and lauded playwrights. With a writing career that spans 36 (easily attributable) plays, an interesting aspect of his work is that these plays can be split up into well defined categories: comedies, tragedies, and histories. Comedies have happy endings and are uplifting, where the main characters overcome some obstacle. Tragedies generally end with the death of a flawed main character. However, <strong>how can we formalize the difference between comedies and tragedies?</strong> This is what weâ€™ll tackle in this article, but we wonâ€™t do it in the way you might expect.</p><p>My research (see: <a href=\"https://cameronraymond.me/\">cameronraymond.me</a>) focuses on networks and how the connections between us shape our world. While plenty of people have analyzed the dialogue of Shakespeareâ€™s plays, far fewer have bothered to look at the differences in how characters relate to each other. Comedyâ€™s and tragedies are very different â€”  not just in terms of the dialogue used, but in how the characters and scenes are structured in relation to each other. <strong>Iâ€™m going to show that by only looking at the structure of a Shakespeareâ€™s plays, and not looking at any of the dialogue, we can determine which plays are comedies and which are tragedies.</strong></p><p>Admittedly, this may seem odd at first. If you want to know a comedy from a tragedy, why wouldnâ€™t you look at the actual dialogue?</p><p>I would argue that <em>not</em> <em>relying</em> on language is an asset because while not everyone speaks the same language, <strong>most stories are driven by  relationships between characters</strong>. A â€œnetwork-firstâ€ approach gives us a more universal comparison of storytelling in a way that isnâ€™t blocked by language barriers. Approaches that rely on natural language processing (NLP) need to know how to interpret different languages as well as different uses of the same language! An NLP model that learns from <em>West Side Story</em> may have a hard time interpreting <em>Romeo and Juliet</em>, even though theyâ€™re both in English and follow identical story arcs. A network-first approach has the potential to pick up on the relational similarities between the two, despite the generational gap. Therefore, the aim is to test if the structure of Shakespeareâ€™s comedies and tragedies are distinct enough to distinguish between the two, without relying on any understanding of language.</p><h2 id=\"the-data\">The Data</h2>\n<p>Thankfully, most of Shakespeareâ€™s plays have been digitized. Using a <a href=\"https://www.kaggle.com/kingburrito666/shakespeare-plays/\">Kaggle data-set</a> we can download all 36 plays and load their scripts into a dataframe. Since scripts contain stage directions, which donâ€™t give information about how characters relate to one another, weâ€™ll drop those rows. Since we wonâ€™t be analyzing Shakespeare&#39;s histories we can also drop those.</p><pre><code class=\"language-python\">import pandas as pd\n\nplays_df = pd.read_csv(&quot;Shakespeare_data.csv&quot;)\n# Drop stage directions (where there isn&#39;t an act/scene/line)\nplays_df = plays_df[pd.notna(plays_df[&#39;ActSceneLine&#39;])]\nplays_df[[&#39;Act&#39;,&#39;Scene&#39;,&#39;Line&#39;]] = plays_df[&#39;ActSceneLine&#39;].str.split(&#39;.&#39;,expand= True).astype(float)\nplays_df = plays_df.drop(&#39;ActSceneLine&#39;,axis=1)\n\n# Drop Shakespeare&#39;s histories\nhistories = [&quot;King John&quot;, &quot;Henry Iv&quot;, &quot;Henry Vi Part 1&quot;, &quot;Henry V&quot;,\n            &quot;Henry Vi Part 2&quot;, &quot;Henry Vi Part 3&quot;, &quot;Henry Viii&quot;,\n            &quot;Richard Ii&quot;, &quot;Richard Iii&quot;]\nplays_df = plays_df[~plays_df[&quot;Play&quot;].isin(histories)]\n\nprint(&quot;{} rows and {} columns&quot;.format(*plays_df.shape))\nplays_df.head()\n</code></pre>\n<img src=\"https://cdn-images-1.medium.com/max/2000/1*SUe3_PbkcZwIC1ihB8UTaw.png\" alt=\"\">\n<p>Now that the data is in a usable format we can start building our networks (one for each play). Since weâ€™re interested in how characters relate to each other weâ€™ll add a link, also called an edge, between two characters if they <em>speak in the same scene</em>. Characters that speak together frequently are probably connected in some meaningful way. This will form the basis for our network-first classification model.</p><p>Letâ€™s use Shakespeareâ€™s 1623 play <em>Allâ€™s Well That Ends Well</em> as an example. First weâ€™ll isolate for that playâ€™s dialogue. Then weâ€™ll  calculate how many times each character speaks, and keep those who meaningfully contribute to the structure of the play (those that speak more than 5 times).</p><pre><code class=\"language-python\">play_name = &quot;Alls Well That Ends Well&quot;\n\nsingle_play = plays_df[(plays_df[&#39;Play&#39;] == play_name)]\n\n# Group the df by character to get how often each speak\ncharacters = single_play.groupby([&#39;Player&#39;]).size().reset_index()\ncharacters.rename(columns = {0: &#39;Count&#39;}, inplace = True)\n# Get top 20 characters\ncharacters = characters[characters[&quot;Count&quot;] &gt; 5]\n</code></pre>\n<p>Next weâ€™ll create the network. We can do this by going scene by scene and adding a link between two characters if they speak in the same scene. The more times those characters  speak together in different scenes, the stronger their link will be.</p><pre><code class=\"language-python\">from itertools import combinations\nfrom networkx import write_gpickle as write_g\nimport networkx as nx\n\nplay_graph = nx.Graph()\nplay_graph.add_nodes_from(top_characters[&quot;Player&quot;])\n\n# Group by Act/Scene and count how often each character spoke per scene \nscenes_df = single_play.groupby([&#39;Act&#39;,&#39;Scene&#39;,&#39;Player&#39;]).size()\nscenes_df = scenes_df[scenes_df[&quot;Player&quot;].isin(characters[&quot;Player&quot;])]\nscenes_df.rename(columns = {0: &#39;Count&#39;}, inplace = True)\n\n# Go scene by scene\nfor (act,scene), counts in scenes_df.groupby([&#39;Act&#39;,&#39;Scene&#39;]):\n    # Get all the characters that are in that scene\n    characters = counts[&quot;Player&quot;].tolist()\n    # If a scene contains characters [A,B,C] we want our graph to\n    # contain the edges [(A,B),(A,C),(B,C)]\n    pairs = list(combinations(characters,2))\n    for (a_char, b_char) in pairs:\n        if character_graph.has_edge(a_char, b_char):\n            play_graph[a_char][b_char][&#39;weight&#39;] += 1\n        else:\n            play_graph.add_edge(a_char, b_char,weight=1)\n\nwrite_g(play_graph, &quot;./graphs/{}.gpickle&quot;.format(play_name))\n</code></pre>\n<p>Repeat for all  27 plays, visualize, and these are the resulting networks! Now we need a way to distinguish between comedies and tragedies that only uses these networks.</p><img src=\"https://cdn-images-1.medium.com/max/2000/1*uNiI3fHUS44j-QorVBxJUA.gif\" alt=\"\">\n<h2 id=\"how-to-compare-networks\">How to Compare Networks</h2>\n<img src=\"https://cdn-images-1.medium.com/max/3782/1*mj4t4Qgu7NzJ7PMJbmeuaQ.png\" alt=\"The traditional way to compare networks.\"><em>The traditional way to compare networks.</em>\n<p>Now that weâ€™ve built networks for Shakespeareâ€™s plays we need some way of distinguishing them. Unfortunately, there isnâ€™t some straightforward way of comparing the structure of two networks. Traditionally, the most dominant method of comparison was called graph edit distance (GED). This method calculates how many edges would need to be reassigned between the two networks before they became identical. This is visualized in the image above. Unfortunately, this relies on each graph having the same number of nodes â€” or else theyâ€™d never be identical. Since our plays have a varied number of characters, weâ€™ll need to turn to something else. <strong>GED is also relatively simple, and rarely captures the underlying structure of a network, so a more nuanced comparison method is needed.</strong></p><img src=\"https://cdn-images-1.medium.com/max/2652/1*6RY31uhk5CKOw0Uw218LPg.png\" alt=\"Two graphs with similar structures despite different densities. [Source](https://www.youtube.com/watch?v=aiPOa1NTgvM).\"><em>Two graphs with similar structures despite different densities. <a href=\"https://www.youtube.com/watch?v=aiPOa1NTgvM\">Source</a>.</em>\n<p>To solve this, we turn to a 2018 paper published in the <em>International Conference on Knowledge Discovery &amp; Data Mining.</em> These researchers define that two graphs are similar if information would flow through them in similar ways over timeÂ¹. The resulting method is called a Network Laplacian Spectral Descriptor, or NetLSD for short. Theyâ€™re assumption is that information flows through a network similar to how heat diffuses throughout your air ducts. If each node in your network gives off some of its â€œheatâ€ over time and passes it along the edges to its neighbors, then over time it will produce a signature that captures the networkâ€™s structure. So at each time step, all you have to do is sum up the amount of â€œheatâ€ in the network. This is represented by  <em>h(t)</em> and is visualized as the y-axis in the image below. Since each heat trace signature uses the same number of time steps, itâ€™s much easier to compare networks of different sizes. By using this technique they were able to identify between different types of proteins and enzymes with a high level of accuracy (94â€“95%)Â¹.</p><img src=\"https://cdn-images-1.medium.com/max/2478/1*Ft99g3Ecrk6WPm1E76LQ1Q.png\" alt=\"NetLSD Heat signatures for two similar graphs: Source: Tsitsulin et al.\"><em>NetLSD Heat signatures for two similar graphs: Source: Tsitsulin et al.</em>\n<p>While implementing NetLSD is relatively simple (especially if you use their <a href=\"https://pypi.org/project/NetLSD/\">Python</a> package) it does requires some background knowledge in how computers represent networks and linear algebra. For those who are interested hereâ€™s the <a href=\"https://arxiv.org/abs/1805.10712\">original paper</a>. Since NetLSDâ€™s inner workings arenâ€™t crucial to our task of classifying comedies and  tragedies, Iâ€™ll move along.</p><h2 id=\"putting-everything-together\">Putting Everything Together</h2>\n<p>Now that we have a way of comparing networks in a meaningful way we can classify different plays. First, weâ€™ll split the 27 plays up into two buckets: our training data, observed plays where we know the genre, and testing data, unknown plays that will be classified. Weâ€™ll use our knowledge of the previously observed plays to help classify the unknown ones. Since there are so few plays, Iâ€™ll reserve a third of the plays as testing data to validate the model.</p><pre><code class=\"language-python\">from sklearn.model_selection import train_test_split\nfrom numpy import concatenate as concat\n\ncom = [â€œA Midsummer Nights Dreamâ€, â€œA Comedy Of Errorsâ€,\n        â€œTaming Of The Shrewâ€,â€œTwo Gentlemen Of Veronaâ€,\n        â€œLoves Labours Lostâ€, â€œThe Tempestâ€,â€œA Winters Taleâ€,\n        â€œCymbelineâ€, â€œPericlesâ€,â€Alls Well That Ends Wellâ€,\n        â€œMeasure For Measureâ€, â€œTroilus And Cressidaâ€,\n        â€œTwelfth Nightâ€,â€œAs You Like Itâ€,\n        â€œMuch Ado About Nothingâ€, â€œMerchant Of Veniceâ€,\n        â€œMerry Wives Of Windsorâ€]\n\ntrag = [â€œMacbethâ€,â€Titus Andronicusâ€, â€œRomeo And Julietâ€,\n        â€œKing Learâ€,â€œHamletâ€,â€Othelloâ€, â€œJulius Caesarâ€,\n        â€œAntony And Cleopatraâ€, â€œCoriolanusâ€, â€œTimon Of Athensâ€]\n\ndata = np.array(com+trag)\n\n# Labels are what we&#39;re trying to predict (comedy or tragedy) \nlabels = concat([np.full(len(com), â€œcâ€),np.full(len(trag), â€œtâ€)])\n\npriors, test_data, prior_labels, test_labels = train_test_split(data, labels, test_size=0.33)\n</code></pre>\n<p>Next weâ€™ll take all of our training data, the plays where we know the genre, and calculate their heat trace signatures.</p><pre><code class=\"language-python\">import netlsd\nfrom networkx import read_gpickle as read_g \n\nargs = { &quot;timescales&quot;: np.logspace(-2, 2, 250), &quot;normalization&quot;: &quot;empty&quot; }\n\nget_sig = lambda title: netlsd.heat(read_g(&quot;./graphs/{}.gpickle&quot;.format(title)),**args)\n\nprior_sigs =[get_sig(title) for title in priors]\n</code></pre>\n<p>Letâ€™s see if thereâ€™s a noticeable difference in how heat flows through a comedy vs a tragedy. Itâ€™s a little muddled, but it seems like tragedies retain more â€œheatâ€ than comedies on average. Using these signatures we can start classifying the unknown plays.</p><img src=\"https://cdn-images-1.medium.com/max/2000/1*M7p1MtnXtXb-nFcVhxnqUg.png\" alt=\"Heat signatures for the prior observed plays (aka â€˜training dataâ€™)\"><em>Heat signatures for the prior observed plays (aka â€˜training dataâ€™)</em>\n<p>The process for classifying a new play is relatively simple. We calculate the unobserved playâ€™s heat trace signature, and then find the five prior observed plays with the closest heat trace signatures. If the majority of those five are comedies then we label that play as a comedy, otherwise we label it as a tragedy. This is whatâ€™s called a k-nearest neighbor (KNN) classifier. KNNs donâ€™t really model anything per say â€” which is why I prefer the term priors to training data â€” but with so few plays to work with a KNN is a reasonable choice.</p><pre><code class=\"language-python\">from netlsd import compare as l2_distance\n\ndef knn_predict(title, prior_sigs, prior_labels,k=5):\n    graph_sig = get_sig(title)\n    distances = [l2_distance(graph_sig,ps) for ps in prior_sigs]\n    total = pd.DataFrame({&quot;ptype&quot;: prior_labels, &quot;dist&quot;: distances})\n    total = total.sort_values(&quot;Distance From Input&quot;)\n    return total[&quot;ptype&quot;].head(k).mode()[0]\n\npred = [knn_predict(play,prior_sigs,prior_labels) for play in data_test]\n</code></pre>\n<p>So howâ€™d we do? Well, <strong>we were able to correctly classify 7 of the  9 plays in our testing data for a raw accuracy of 77.8%.</strong> The testing set contained 7 comedies and 2 tragedies, and we were able to <strong>correctly classify all of the tragedies</strong> and <strong>5/7 comedies</strong>. This shows that comedies and tragedies produce distinct enough structures that we can tell which is which by only looking at the networks.</p><img src=\"https://cdn-images-1.medium.com/max/2000/1*LW_8KmcdOQtSUOVec9B9hQ.png\" alt=\"Comedy/tragedy classification confusion matrix.\"><em>Comedy/tragedy classification confusion matrix.</em>\n<h2 id=\"so-what\">So What?</h2>\n<p>While 27 plays is a small sample, Iâ€™d argue that the principles of this experiment are sound. <strong>A network first approach lets  us do something that, at first glance, seem pretty unlikely: we are able to figure out the genre of a play without looking at a single piece of dialogue.</strong> Personally, I  think that is pretty cool.</p><p>So are you saying this means we donâ€™t care about NLP anymore?</p><p>Obviously not. Thereâ€™s a ton of rich information in language thatâ€™s lost when something like a play is abstracted into a network. However, networks give researchers flexibility to not rely on, or be bound by, language. This goes back to the example of comparing plays in different languages or from different time periods. And the applications donâ€™t stop at comparing plays or movies. Disinformation is often spread en-mass by creating networks of social media bots that retweet and amplify each others fake news to give the illusion of legitimacy. Rather than focusing on what an account is saying, it could be more helpful to see if itâ€™s connection network is similar to networks of disinformation bots that have been taken down. <strong>There are plenty of potential applications because networks are so malleable and can be used to represent almost anything.</strong> If you want to learn more about network science/graph theory and itâ€™s applications, check out my website below! It has links to all my work.</p><p>[1]: Tsitsulin, Anton, Davide Mottin, Panagiotis Karras, Alexander Bronstein, and Emmanuel MÃ¼ller. â€œNetlsd: hearing the shape of a graph.â€ In <em>Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining</em>, pp. 2347â€“2356. 2018.</p>"}